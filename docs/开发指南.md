# 多人屏幕共享系统 - 开发指南

## 文档信息

| 项目名称 | 多人屏幕共享系统 |
|---------|-----------------|
| 文档版本 | v1.0 |
| 创建日期 | 2026-01-04 |
| 文档类型 | 开发指南 |

---

## 1. 快速开始

### 1.1 环境准备

#### 1.1.1 必需工具

| 工具 | 版本 | 安装方式 |
|------|------|---------|
| **Node.js** | 20.x LTS | https://nodejs.org/ 或 nvm |
| **npm** | 10.x+ | 随Node.js安装 |
| **Git** | 2.x+ | https://git-scm.com/ |
| **VSCode** | 最新版 | https://code.visualstudio.com/ |

#### 1.1.2 推荐VSCode插件

```json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-typescript-next",
    "bradlc.vscode-tailwindcss",
    "dsznajder.es7-react-js-snippets"
  ]
}
```

---

### 1.2 克隆项目

```bash
# 克隆仓库
git clone https://github.com/your-org/screen-sharing.git
cd screen-sharing

# 查看项目结构
ls -la
```

---

### 1.3 安装依赖

```bash
# 安装根目录依赖（如果有）
npm install

# 安装共享模块依赖
cd shared
npm install
npm run build
cd ..

# 安装服务端依赖
cd server
npm install
cd ..

# 安装客户端依赖
cd client
npm install
cd ..
```

---

### 1.4 启动开发环境

#### 1.4.1 启动服务端

```bash
cd server

# 开发模式（热重载）
npm run dev

# 或手动启动
npm run build
npm start
```

服务端将在 `http://localhost:3000` 启动

#### 1.4.2 启动客户端

```bash
cd client

# 开发模式
npm run dev
```

这将同时启动Electron应用和Vite开发服务器

---

## 2. 项目结构详解

### 2.1 整体结构

```
screen-sharing/
├── client/              # 客户端（Electron应用）
├── server/              # 服务端（Node.js信令服务器）
├── shared/              # 共享代码（类型定义、常量等）
├── docs/                # 项目文档
├── plans/               # 规划文档
├── .gitignore
├── package.json
└── README.md
```

### 2.2 客户端结构说明

```
client/
├── src/
│   ├── main/            # Electron主进程
│   │   ├── index.ts     # 主进程入口
│   │   ├── window.ts    # 窗口管理
│   │   └── ipc/         # IPC通信处理器
│   │
│   ├── renderer/        # 渲染进程（React应用）
│   │   ├── pages/       # 页面组件
│   │   ├── components/  # 可复用组件
│   │   ├── services/    # 业务服务
│   │   ├── store/       # 状态管理
│   │   ├── hooks/       # 自定义Hooks
│   │   └── utils/       # 工具函数
│   │
│   └── preload/         # 预加载脚本
│       └── index.ts
│
├── public/              # 静态资源
├── build/               # 构建配置和图标
└── package.json
```

### 2.3 服务端结构说明

```
server/
├── src/
│   ├── index.ts         # 服务入口
│   ├── config/          # 配置管理
│   ├── controllers/     # 控制器
│   ├── services/        # 业务逻辑
│   ├── socket/          # Socket.io事件处理
│   ├── models/          # 数据模型
│   ├── types/           # 类型定义
│   ├── utils/           # 工具函数
│   └── middleware/      # 中间件
│
├── logs/                # 日志文件（gitignore）
├── config/              # 环境配置文件
└── package.json
```

---

## 3. 开发规范

### 3.1 代码风格

#### 3.1.1 TypeScript规范

```typescript
// ✅ 好的写法
interface User {
  id: string;
  nickname: string;
  avatar?: string;
}

function getUserById(userId: string): User | null {
  // 实现...
  return null;
}

// ❌ 避免使用any
function badFunction(data: any) {
  return data;
}

// ✅ 使用具体类型
function goodFunction(data: User) {
  return data;
}
```

#### 3.1.2 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| **变量** | camelCase | `userName`, `roomId` |
| **常量** | UPPER_SNAKE_CASE | `MAX_ROOM_SIZE`, `API_URL` |
| **函数** | camelCase | `createRoom()`, `handleClick()` |
| **类** | PascalCase | `RoomService`, `UserManager` |
| **接口** | PascalCase | `User`, `RoomInfo` |
| **类型** | PascalCase | `RoomType`, `StreamConfig` |
| **组件** | PascalCase | `UserList`, `VideoGrid` |
| **文件** | kebab-case | `user-list.tsx`, `room-service.ts` |

#### 3.1.3 注释规范

```typescript
/**
 * 创建新房间
 * @param name 房间名称
 * @param password 房间密码（可选）
 * @returns 房间ID
 * @throws {Error} 当房间名称无效时抛出错误
 */
function createRoom(name: string, password?: string): string {
  // 验证房间名称
  if (!name || name.length === 0) {
    throw new Error('Room name is required');
  }
  
  // 生成房间ID
  const roomId = generateRoomId();
  
  return roomId;
}
```

---

### 3.2 Git工作流

#### 3.2.1 分支命名

| 分支类型 | 命名格式 | 示例 |
|---------|---------|------|
| **主分支** | `main` | `main` |
| **开发分支** | `develop` | `develop` |
| **功能分支** | `feature/描述` | `feature/add-chat` |
| **修复分支** | `fix/描述` | `fix/connection-bug` |
| **发布分支** | `release/版本号` | `release/v1.0.0` |

#### 3.2.2 提交规范

使用 Conventional Commits 规范：

```bash
# 格式
<type>(<scope>): <subject>

# 类型说明
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式（不影响代码运行）
refactor: 重构
perf:     性能优化
test:     测试
chore:    构建过程或辅助工具的变动

# 示例
git commit -m "feat(client): 添加屏幕共享功能"
git commit -m "fix(server): 修复房间创建失败的问题"
git commit -m "docs: 更新API文档"
```

#### 3.2.3 工作流程

```bash
# 1. 从develop创建功能分支
git checkout develop
git pull origin develop
git checkout -b feature/new-feature

# 2. 开发并提交
git add .
git commit -m "feat: 实现新功能"

# 3. 推送到远程
git push origin feature/new-feature

# 4. 创建Pull Request到develop分支

# 5. 代码审查通过后合并

# 6. 删除功能分支
git branch -d feature/new-feature
git push origin --delete feature/new-feature
```

---

## 4. 核心功能开发

### 4.1 客户端开发

#### 4.1.1 创建新页面

```typescript
// client/src/renderer/pages/NewPage/index.tsx
import React from 'react';

interface NewPageProps {
  // 定义props类型
}

const NewPage: React.FC<NewPageProps> = () => {
  return (
    <div className="new-page">
      <h1>New Page</h1>
    </div>
  );
};

export default NewPage;
```

#### 4.1.2 添加路由

```typescript
// client/src/renderer/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import NewPage from './pages/NewPage';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/new" element={<NewPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

#### 4.1.3 状态管理（Zustand）

```typescript
// client/src/renderer/store/room.ts
import { create } from 'zustand';

interface RoomState {
  roomId: string | null;
  members: User[];
  streams: Stream[];
  
  // Actions
  setRoomId: (roomId: string) => void;
  addMember: (member: User) => void;
  removeMember: (userId: string) => void;
}

export const useRoomStore = create<RoomState>((set) => ({
  roomId: null,
  members: [],
  streams: [],
  
  setRoomId: (roomId) => set({ roomId }),
  
  addMember: (member) => set((state) => ({
    members: [...state.members, member]
  })),
  
  removeMember: (userId) => set((state) => ({
    members: state.members.filter(m => m.id !== userId)
  }))
}));
```

使用状态：

```typescript
// 在组件中使用
function RoomComponent() {
  const { roomId, members, setRoomId } = useRoomStore();
  
  return (
    <div>
      <p>Room ID: {roomId}</p>
      <p>Members: {members.length}</p>
    </div>
  );
}
```

#### 4.1.4 WebRTC连接

```typescript
// client/src/renderer/services/webrtc/peer-connection.ts
export class PeerConnectionManager {
  private peerConnections: Map<string, RTCPeerConnection> = new Map();
  private config: RTCConfiguration = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }
    ]
  };
  
  async createConnection(
    remoteUserId: string,
    localStream: MediaStream
  ): Promise<RTCPeerConnection> {
    const pc = new RTCPeerConnection(this.config);
    
    // 添加本地流
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });
    
    // 处理ICE候选
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        this.sendIceCandidate(remoteUserId, event.candidate);
      }
    };
    
    // 处理连接状态变化
    pc.onconnectionstatechange = () => {
      console.log('Connection state:', pc.connectionState);
    };
    
    this.peerConnections.set(remoteUserId, pc);
    return pc;
  }
  
  async createOffer(remoteUserId: string): Promise<RTCSessionDescriptionInit> {
    const pc = this.peerConnections.get(remoteUserId);
    if (!pc) throw new Error('PeerConnection not found');
    
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    return offer;
  }
  
  async handleAnswer(
    remoteUserId: string,
    answer: RTCSessionDescriptionInit
  ): Promise<void> {
    const pc = this.peerConnections.get(remoteUserId);
    if (!pc) throw new Error('PeerConnection not found');
    
    await pc.setRemoteDescription(answer);
  }
  
  closeConnection(remoteUserId: string): void {
    const pc = this.peerConnections.get(remoteUserId);
    if (pc) {
      pc.close();
      this.peerConnections.delete(remoteUserId);
    }
  }
  
  private sendIceCandidate(userId: string, candidate: RTCIceCandidate): void {
    // 通过Socket.io发送ICE候选
  }
}
```

#### 4.1.5 屏幕捕获

```typescript
// client/src/renderer/services/screen/capture.ts
export class ScreenCaptureService {
  async getSources(): Promise<Electron.DesktopCapturerSource[]> {
    // 通过IPC调用主进程的desktopCapturer
    const sources = await window.electron.getDesktopSources({
      types: ['screen', 'window'],
      thumbnailSize: { width: 300, height: 200 }
    });
    
    return sources;
  }
  
  async getStreamFromSource(
    sourceId: string
  ): Promise<MediaStream> {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: sourceId,
          minWidth: 1280,
          maxWidth: 1920,
          minHeight: 720,
          maxHeight: 1080
        }
      } as any
    });
    
    return stream;
  }
}
```

---

### 4.2 服务端开发

#### 4.2.1 创建新的Socket事件处理器

```typescript
// server/src/socket/handlers/custom.handler.ts
import { Socket } from 'socket.io';
import { logger } from '../../utils/logger';

export function setupCustomHandlers(socket: Socket) {
  socket.on('custom-event', async (data, callback) => {
    try {
      logger.info('Custom event received', { socketId: socket.id, data });
      
      // 处理业务逻辑
      const result = await processCustomEvent(data);
      
      // 返回结果
      callback({ success: true, data: result });
    } catch (error) {
      logger.error('Error handling custom event', { error });
      callback({ success: false, error: error.message });
    }
  });
}

async function processCustomEvent(data: any): Promise<any> {
  // 实现业务逻辑
  return { processed: true };
}
```

注册处理器：

```typescript
// server/src/socket/index.ts
import { setupCustomHandlers } from './handlers/custom.handler';

io.on('connection', (socket) => {
  // 注册处理器
  setupCustomHandlers(socket);
});
```

#### 4.2.2 创建新的Service

```typescript
// server/src/services/custom.service.ts
export class CustomService {
  private data: Map<string, any> = new Map();
  
  create(id: string, data: any): void {
    this.data.set(id, data);
  }
  
  get(id: string): any | undefined {
    return this.data.get(id);
  }
  
  update(id: string, data: any): void {
    const existing = this.data.get(id);
    if (existing) {
      this.data.set(id, { ...existing, ...data });
    }
  }
  
  delete(id: string): void {
    this.data.delete(id);
  }
  
  getAll(): any[] {
    return Array.from(this.data.values());
  }
}

// 单例导出
export const customService = new CustomService();
```

#### 4.2.3 添加中间件

```typescript
// server/src/middleware/auth.middleware.ts
import { Socket } from 'socket.io';
import { ExtendedError } from 'socket.io/dist/namespace';

export function authMiddleware(
  socket: Socket,
  next: (err?: ExtendedError) => void
) {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication token required'));
  }
  
  try {
    // 验证token
    const decoded = verifyToken(token);
    socket.data.userId = decoded.userId;
    next();
  } catch (error) {
    next(new Error('Invalid token'));
  }
}

function verifyToken(token: string): any {
  // 实现token验证逻辑
  return { userId: 'user-123' };
}
```

注册中间件：

```typescript
// server/src/socket/index.ts
import { authMiddleware } from '../middleware/auth.middleware';

io.use(authMiddleware);
```

---

## 5. 测试

### 5.1 单元测试

#### 5.1.1 Jest配置

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.test.ts'
  ]
};
```

#### 5.1.2 编写测试

```typescript
// server/src/services/__tests__/room.service.test.ts
import { RoomService } from '../room.service';

describe('RoomService', () => {
  let roomService: RoomService;
  
  beforeEach(() => {
    roomService = new RoomService();
  });
  
  describe('createRoom', () => {
    it('should create a room with valid name', () => {
      const room = roomService.createRoom('Test Room');
      
      expect(room).toBeDefined();
      expect(room.name).toBe('Test Room');
      expect(room.id).toHaveLength(6);
    });
    
    it('should throw error for empty name', () => {
      expect(() => {
        roomService.createRoom('');
      }).toThrow('Room name is required');
    });
  });
  
  describe('getRoom', () => {
    it('should return room if exists', () => {
      const created = roomService.createRoom('Test Room');
      const found = roomService.getRoom(created.id);
      
      expect(found).toEqual(created);
    });
    
    it('should return null if room does not exist', () => {
      const found = roomService.getRoom('nonexistent');
      
      expect(found).toBeNull();
    });
  });
});
```

运行测试：

```bash
# 运行所有测试
npm test

# 运行特定测试
npm test -- room.service

# 生成覆盖率报告
npm test -- --coverage
```

---

### 5.2 集成测试

```typescript
// server/src/__tests__/integration/socket.test.ts
import { io as Client, Socket as ClientSocket } from 'socket.io-client';
import { createServer } from '../../../test-utils/server';

describe('Socket Integration Tests', () => {
  let serverSocket: any;
  let clientSocket: ClientSocket;
  let serverUrl: string;
  
  beforeAll((done) => {
    const { server, url } = createServer();
    serverUrl = url;
    server.on('connection', (socket) => {
      serverSocket = socket;
    });
    done();
  });
  
  beforeEach((done) => {
    clientSocket = Client(serverUrl, {
      auth: { nickname: 'Test User' }
    });
    clientSocket.on('connect', done);
  });
  
  afterEach(() => {
    clientSocket.close();
  });
  
  it('should create a room', (done) => {
    clientSocket.emit('create-room', {
      name: 'Test Room'
    });
    
    clientSocket.on('room-created', (response) => {
      expect(response.success).toBe(true);
      expect(response.roomId).toBeDefined();
      done();
    });
  });
});
```

---

## 6. 调试技巧

### 6.1 客户端调试

#### 6.1.1 Chrome DevTools

```typescript
// 在代码中添加断点
debugger;

// 使用console进行调试
console.log('Debug info:', data);
console.table(users);
console.group('WebRTC Connection');
console.log('Offer:', offer);
console.log('Answer:', answer);
console.groupEnd();
```

#### 6.1.2 VSCode调试配置

创建 `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Electron Main",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceFolder}/client",
      "runtimeExecutable": "${workspaceFolder}/client/node_modules/.bin/electron",
      "windows": {
        "runtimeExecutable": "${workspaceFolder}/client/node_modules/.bin/electron.cmd"
      },
      "args": ["."],
      "outputCapture": "std"
    }
  ]
}
```

---

### 6.2 服务端调试

#### 6.2.1 使用VSCode调试

创建 `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Server",
      "cwd": "${workspaceFolder}/server",
      "runtimeArgs": [
        "-r",
        "ts-node/register"
      ],
      "args": [
        "${workspaceFolder}/server/src/index.ts"
      ],
      "env": {
        "NODE_ENV": "development"
      }
    }
  ]
}
```

#### 6.2.2 日志调试

```typescript
// 使用Winston日志
import { logger } from './utils/logger';

logger.debug('Debug message', { data });
logger.info('Info message');
logger.warn('Warning message');
logger.error('Error message', { error });
```

---

## 7. 常见问题

### 7.1 开发环境问题

#### Q: npm install 失败

```bash
# 清理缓存
npm cache clean --force

# 删除node_modules和lock文件
rm -rf node_modules package-lock.json

# 重新安装
npm install
```

#### Q: Electron启动失败

```bash
# 重新构建native模块
cd client
npm run rebuild

# 或手动重建
npm rebuild --runtime=electron --target=28.0.0 --disturl=https://electronjs.org/headers
```

#### Q: WebRTC连接失败

检查以下几点：
1. TURN服务器配置是否正确
2. 防火墙是否开放相关端口
3. ICE候选是否正常收集
4. SDP交换是否成功

---

### 7.2 构建问题

#### Q: TypeScript编译错误

```bash
# 检查类型错误
npx tsc --noEmit

# 生成类型定义
npm run build:types
```

#### Q: Electron打包失败

```bash
# 清理构建缓存
rm -rf dist release

# 重新构建
npm run build
npm run build:prod
```

---

## 8. 性能优化建议

### 8.1 前端优化

```typescript
// 1. 使用React.memo避免不必要的重渲染
const UserItem = React.memo(({ user }: { user: User }) => {
  return <div>{user.nickname}</div>;
});

// 2. 使用useMemo缓存计算结果
const sortedUsers = useMemo(() => {
  return users.sort((a, b) => a.nickname.localeCompare(b.nickname));
}, [users]);

// 3. 使用useCallback缓存回调函数
const handleClick = useCallback(() => {
  console.log('Clicked');
}, []);

// 4. 懒加载组件
const Settings = lazy(() => import('./pages/Settings'));
```

### 8.2 后端优化

```typescript
// 1. 使用对象池复用资源
class ObjectPool<T> {
  private pool: T[] = [];
  
  acquire(factory: () => T): T {
    return this.pool.pop() || factory();
  }
  
  release(obj: T): void {
    this.pool.push(obj);
  }
}

// 2. 批量处理消息
class MessageBatcher {
  private queue: any[] = [];
  private timer: NodeJS.Timeout | null = null;
  
  add(message: any): void {
    this.queue.push(message);
    
    if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), 100);
    }
  }
  
  private flush(): void {
    if (this.queue.length > 0) {
      this.processMessages(this.queue);
      this.queue = [];
    }
    this.timer = null;
  }
  
  private processMessages(messages: any[]): void {
    // 批量处理
  }
}
```

---

## 9. 发布流程

### 9.1 版本管理

```bash
# 更新版本号
npm version patch  # 1.0.0 -> 1.0.1
npm version minor  # 1.0.0 -> 1.1.0
npm version major  # 1.0.0 -> 2.0.0

# 创建发布标签
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0
```

### 9.2 构建发布包

```bash
# 客户端
cd client
npm run build:prod

# 服务端
cd server
npm run build
```

### 9.3 发布检查清单

- [ ] 所有测试通过
- [ ] 代码已合并到main分支
- [ ] 版本号已更新
- [ ] CHANGELOG已更新
- [ ] 文档已更新
- [ ] 构建无错误
- [ ] 手动测试核心功能
- [ ] 创建Git标签

---

## 10. 资源链接

### 10.1 官方文档

- **Electron**: https://www.electronjs.org/docs
- **React**: https://react.dev/
- **TypeScript**: https://www.typescriptlang.org/docs/
- **Socket.io**: https://socket.io/docs/v4/
- **WebRTC**: https://webrtc.org/getting-started/overview

### 10.2 学习资源

- **WebRTC教程**: https://webrtc.org/getting-started/overview
- **Electron实践**: https://www.electronjs.org/docs/latest/tutorial/quick-start
- **React最佳实践**: https://react.dev/learn

### 10.3 工具推荐

- **Postman**: API测试工具
- **WebRTC Internals**: chrome://webrtc-internals
- **React DevTools**: React调试工具
- **Redux DevTools**: 状态管理调试工具

---

## 附录：常用代码片段

### A.1 创建React组件模板

```typescript
import React from 'react';

interface ComponentNameProps {
  // props定义
}

export const ComponentName: React.FC<ComponentNameProps> = (props) => {
  // 状态
  const [state, setState] = React.useState();
  
  // 副作用
  React.useEffect(() => {
    // 初始化
    return () => {
      // 清理
    };
  }, []);
  
  // 事件处理
  const handleEvent = () => {
    // 处理逻辑
  };
  
  // 渲染
  return (
    <div className="component-name">
      {/* JSX */}
    </div>
  );
};
```

### A.2 Socket事件处理模板

```typescript
import { Socket } from 'socket.io';

export function setupEventHandlers(socket: Socket) {
  socket.on('event-name', async (data, callback) => {
    try {
      // 数据验证
      validateData(data);
      
      // 业务逻辑
      const result = await processEvent(data);
      
      // 返回结果
      callback({ success: true, data: result });
      
    } catch (error) {
      callback({ 
        success: false, 
        error: error.message 
      });
    }
  });
}
```

---

**文档结束**
